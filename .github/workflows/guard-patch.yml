# ========================== [01] guard-patch.yml â€” START ==========================
name: CI â€¢ Patch Guard

on:
  pull_request:
    types: [opened, reopened, synchronize, edited]

permissions:
  contents: read
  pull-requests: read

jobs:
  patch-guard:
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ§° Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: ğŸ“¦ Install deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install pyyaml

      - name: ğŸ” Run Patch Guard
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
        run: |
          set -euo pipefail
          python - <<'PYCODE'
import os, sys, re, hashlib, subprocess, json, pathlib
try:
    import yaml  # type: ignore
except Exception as e:
    print("::error::pyyaml not available", flush=True)
    sys.exit(1)

BASE_REF = os.environ.get("BASE_REF", "main")
PR_BODY  = os.environ.get("PR_BODY", "") or ""
CFG_PATH = ".ci/patch-guard.yml"

def load_cfg():
    # 1) repo file ìš°ì„ 
    if pathlib.Path(CFG_PATH).exists():
        with open(CFG_PATH, "r", encoding="utf-8") as f:
            return yaml.safe_load(f) or {}
    # 2) PR body ë‚´ HTML ì£¼ì„ ë¸”ë¡ íŒŒì‹±
    m = re.search(r"<!--\s*PATCH-GUARD\s*(.*?)-->", PR_BODY, re.S | re.I)
    if not m:
        print("::error::.ci/patch-guard.yml ë˜ëŠ” PR ë³¸ë¬¸ì˜ <!-- PATCH-GUARD ... --> ë¸”ë¡ì´ í•„ìš”í•©ë‹ˆë‹¤.")
        sys.exit(1)
    content = m.group(1)
    try:
        return yaml.safe_load(content) or {}
    except Exception as e:
        print(f"::error::PR ë³¸ë¬¸ì˜ PATCH-GUARD YAML íŒŒì‹± ì‹¤íŒ¨: {e}")
        sys.exit(1)

def git_show(ref, path):
    r = subprocess.run(["git","fetch","origin", ref], capture_output=True, text=True)
    # ignore failure (branch may already be fetched)
    r = subprocess.run(["git","show", f"origin/{ref}:{path}"], capture_output=True)
    return r.returncode, r.stdout, r.stderr

cfg = load_cfg()
files = cfg.get("files", [])
if not isinstance(files, list) or not files:
    print("::error::PATCH-GUARD ì„¤ì •ì— files ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
    sys.exit(1)

errors = []
for i, item in enumerate(files, 1):
    path = str(item.get("path", "")).strip()
    exp_sha = (item.get("sha256") or "").strip()
    anchors = item.get("anchors", [])
    if not path:
        errors.append(f"[item {i}] path ëˆ„ë½")
        continue
    code, data, err = git_show(BASE_REF, path)
    if code != 0:
        errors.append(f"{path}: origin/{BASE_REF}ì—ì„œ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
        continue
    h = hashlib.sha256(data).hexdigest()
    if exp_sha:
        if h != exp_sha:
            errors.append(f"{path}: sha256 ë¶ˆì¼ì¹˜ (expected={exp_sha}, got={h})")
    # anchor ê²€ì‚¬ (string í¬í•¨ ë˜ëŠ” ì •ê·œì‹: 're:...')
    try:
        text = data.decode("utf-8", errors="ignore")
    except Exception:
        text = ""
    for a in anchors or []:
        if isinstance(a, str) and a.startswith("re:"):
            pat = a[3:]
            if not re.search(pat, text, re.S):
                errors.append(f"{path}: anchor regex ë¯¸ì¡´ì¬: {pat}")
        else:
            s = str(a)
            if s not in text:
                errors.append(f"{path}: anchor ë¬¸ìì—´ ë¯¸ì¡´ì¬: {s}")

if errors:
    print("::error::Patch Guard ì‹¤íŒ¨:\n- " + "\n- ".join(errors))
    sys.exit(1)
print("Patch Guard OK")
PYCODE
# ========================== [01] guard-patch.yml â€” END ============================
