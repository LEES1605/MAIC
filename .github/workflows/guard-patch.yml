# ========================== [01] ì›Œí¬í”Œë¡œ ë©”íƒ€ â€” START ==========================
name: CI â€¢ Patch Guard
# PRì—ì„œë§Œ ì‹¤í–‰ (pushì—ì„œëŠ” ì ˆëŒ€ ë™ì‘í•˜ì§€ ì•ŠìŒ)
on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review]
permissions:
  contents: read
  pull-requests: read
# ========================== [01] ì›Œí¬í”Œë¡œ ë©”íƒ€ â€” END ============================

# ========================== [02] Patch Guard ì¡ â€” START ========================
jobs:
  patch-guard:
    # ì•ˆì „ì¥ì¹˜: í˜¹ì‹œë¼ë„ pushë¡œ íŠ¸ë¦¬ê±°ë˜ë©´ ìŠ¤í‚µ
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ§° Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: ğŸ“¦ Install deps
        run: python -m pip install --upgrade pip pyyaml

      - name: ğŸ” Run Patch Guard
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PYCODE'
          # =================== [03] Guard Script â€” START ===================
          import os, re, sys, hashlib, subprocess, pathlib, textwrap
          try:
              import yaml  # type: ignore
          except Exception:
              print("::error::pyyaml not available")
              sys.exit(1)

          BASE_REF = os.environ.get("BASE_REF", "main")
          PR_BODY  = os.environ.get("PR_BODY", "") or ""
          CFG_PATH = ".ci/patch-guard.yml"

          def load_cfg():
              # 1) ë¦¬í¬ íŒŒì¼ ìš°ì„ 
              if pathlib.Path(CFG_PATH).exists():
                  with open(CFG_PATH, "r", encoding="utf-8") as f:
                      return yaml.safe_load(f) or {}
              # 2) PR ë³¸ë¬¸ HTML ì£¼ì„ ë¸”ë¡ì—ì„œ ë¡œë“œ
              m = re.search(r"<!--\\s*PATCH-GUARD\\s*(.*?)-->", PR_BODY, re.S | re.I)
              if not m:
                  print("::error::.ci/patch-guard.yml ë˜ëŠ” PR ë³¸ë¬¸ì˜ <!-- PATCH-GUARD ... --> ë¸”ë¡ì´ í•„ìš”í•©ë‹ˆë‹¤.")
                  sys.exit(1)
              try:
                  return yaml.safe_load(m.group(1)) or {}
              except Exception as e:
                  print(f"::error::PR ë³¸ë¬¸ PATCH-GUARD YAML íŒŒì‹± ì‹¤íŒ¨: {e}")
                  sys.exit(1)

          def git_show_base(path: str) -> bytes:
              # base ë¸Œëœì¹˜ ìµœì‹  ìƒíƒœ í™•ë³´ í›„, íŒŒì¼ ë°”ì´íŠ¸ ë¦¬í„´
              subprocess.run(["git", "fetch", "origin", BASE_REF], check=False, capture_output=True)
              r = subprocess.run(["git","show", f"origin/{BASE_REF}:{path}"], capture_output=True)
              if r.returncode != 0:
                  raise FileNotFoundError(f"origin/{BASE_REF}:{path} not found")
              return r.stdout

          cfg = load_cfg()
          files = cfg.get("files", [])
          if not isinstance(files, list) or not files:
              print("::error::PATCH-GUARD ì„¤ì •ì— files ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
              sys.exit(1)

          errors = []
          for i, item in enumerate(files, 1):
              path = str(item.get("path") or "").strip()
              exp_sha = str(item.get("sha256") or "").strip()
              anchors = item.get("anchors") or []
              if not path:
                  errors.append(f"[item {i}] path ëˆ„ë½")
                  continue
              try:
                  data = git_show_base(path)
              except Exception:
                  errors.append(f"{path}: origin/{BASE_REF}ì—ì„œ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                  continue

              sha = hashlib.sha256(data).hexdigest()
              if exp_sha and sha != exp_sha:
                  errors.append(f"{path}: sha256 ë¶ˆì¼ì¹˜ (expected={exp_sha}, got={sha})")

              text = ""
              try:
                  text = data.decode("utf-8", "ignore")
              except Exception:
                  pass

              for a in anchors:
                  if isinstance(a, str) and a.startswith("re:"):
                      pat = a[3:]
                      if not re.search(pat, text, re.S):
                          errors.append(f"{path}: anchor regex ë¯¸ì¡´ì¬: {pat}")
                  else:
                      s = str(a)
                      if s and s not in text:
                          errors.append(f"{path}: anchor ë¬¸ìì—´ ë¯¸ì¡´ì¬: {s}")

          if errors:
              print("::error::Patch Guard ì‹¤íŒ¨:\\n- " + "\\n- ".join(errors))
              sys.exit(1)
          print("Patch Guard OK")
          # =================== [03] Guard Script â€” END =====================
          PYCODE
# ========================== [02] Patch Guard ì¡ â€” END ==========================
