# 스트림릿 오케스트레이터 앱 리팩터링 가이드

## 1. 학생 모드에서 사이드바 숨기기

**문제:**
현재 앱에서는 관리자가 아닌 경우에도 사이드바가 표시되어 학생 모드 사용자에게 불필요한 메뉴가 보입니다. 관리자 전용 페이지(`index_status`, `admin_prompt` 등)나 컨트롤을 학생이 볼 수 있어 혼란을 줄 수 있으므로, 관리자 로그인 여부에 따라 사이드바를 동적으로 표시/숨김 처리해야 합니다.

**해결 방안:**

-   **관리자 여부 확인:** 먼저 세션 상태 등에 `is_admin` 플래그를 두어 사용자가 관리자 권한인지 확인합니다. 예를 들어 로그인 시 입력받은 패스워드를 `st.secrets`와 대조하여 `st.session_state.is_admin = True`를 설정해둘 수 있습니다.

-   **초기 사이드바 상태 설정:** Streamlit의 `st.set_page_config`를 이용해 페이지 로드 시 사이드바를 기본적으로 숨긴 상태로 설정합니다. `initial_sidebar_state="collapsed"` 옵션을 사용하면 앱 실행시 사이드바가 접힌 상태로 시작됩니다. 이 호출은 반드시 앱 스크립트 최상단에서 실행해야 합니다.
    ```python
    if not st.session_state.get('is_admin', False):
        st.set_page_config(layout="wide", initial_sidebar_state="collapsed")
    else:
        st.set_page_config(layout="wide", initial_sidebar_state="expanded")
    ```
    위와 같이 설정하면 학생 모드에서는 사이드바가 처음부터 접혀있게 됩니다. 관리자 모드에서는 필요에 따라 펼쳐서 보여줄 수 있습니다.

-   **사이드바 토글 버튼 제거:** 사이드바 자체를 완전히 숨기려면 접혀있는 상태에서 토글 버튼 (화살표 아이콘)도 보이지 않게 처리해야 합니다. Streamlit에서는 CSS를 주입하여 UI 요소를 숨길 수 있습니다. 예를 들어 아래와 같이 사이드바 토글을 비활성화합니다.
    ```python
    if not st.session_state.get('is_admin', False):
        hide_sidebar_style = """
            <style>
            [data-testid="collapsedControl"] { display: none; }
            </style>
        """
        st.markdown(hide_sidebar_style, unsafe_allow_html=True)
    ```
    이 CSS는 사이드바 펼치기 아이콘 자체를 숨겨주므로, 학생 모드에서는 사이드바를 열 방법이 없어집니다.

-   **관리자 모드 사이드바 표시:** 관리자 모드에서는 위 CSS를 적용하지 않고, 대신 사이드바에 메뉴와 기능을 렌더링합니다. 예를 들어 관리자 전용 페이지 내에서는 `st.sidebar.selectbox` 등을 사용하여 메뉴를 구성합니다. 학생 모드에서는 이러한 사이드바 렌더링 코드를 실행하지 않거나 바로 `st.stop()` 시켜 사이드바가 공백으로 남지 않게 합니다.

-   **구성 옵션 참고:** 스트림릿 구성 파일의 `[client] showSidebarNavigation` 옵션을 활용하면 멀티페이지 앱의 사이드바 메뉴 자체를 전역적으로 비활성화할 수 있습니다. 다만 이 옵션을 `false`로 설정하면 모든 사용자에 대해 사이드바 네비게이션이 숨겨지기 때문에 관리자에게도 메뉴가 보이지 않는 문제가 있습니다. 따라서 본 시나리오처럼 동적으로 제어해야 할 때는, 위에 설명한 코드 기반 접근(CSS 숨김 및 조건부 렌더링)이 필요합니다.

이러한 변경을 통해 학생 모드에서는 사이드바가 완전히 숨겨지고, 관리자 모드로 로그인했을 때만 사이드바 메뉴와 관리자 기능이 노출되도록 합니다. 구현 후 관리자 계정으로 로그인했을 때 사이드바 메뉴가 제대로 보이는지, 로그아웃 또는 학생 모드 전환 시 사이드바가 사라지는지 확인합니다.

---

## 2. GitHub 릴리스 인덱스 복원 오류 수정

**문제:**
앱이 GitHub Releases에서 최신 인덱스(`index-latest` 또는 `indices-latest` 태그) 자산을 자동 복원하려 할 때 404 오류로 실패하고 있습니다. 현재 로직은 특정 태그명을 단순 조회하고 있으나, 실제 릴리스에는 해당 태그가 없거나 API 사용 방식이 잘못되어 릴리스 자산(zip 파일) 로딩에 실패합니다 (예: "no matching release asset. tried: tag:indices-latest 404; tag:index-latest=404..."와 같은 오류 메시지). 또한 GitHub API 호출 중 에러가 발생했을 때 예외 처리가 부족하고, zip 파일 파싱에도 보완이 필요합니다.

**해결 방안:**

-   **최신 릴리스 API 활용:** GitHub API에서는 가장 최근 릴리스를 가져오는 전용 엔드포인트를 제공합니다. `/repos/{owner}/{repo}/releases/latest`를 호출하면 최신의 (draft나 prerelease가 아닌) 릴리스 정보를 JSON으로 반환합니다. 이를 활용하면 특정 태그 이름에 의존하지 않고도 최신 릴리스를 얻을 수 있습니다 (GitHub는 최신 태그를 직접 가져오는 API는 없지만 최신 릴리스에는 전용 API가 있음).

    **구현:** 예를 들어 `requests` 라이브러리를 사용하여 다음과 같이 호출합니다:
    ```python
    import requests

    url = f"[https://api.github.com/repos/](https://api.github.com/repos/){OWNER}/{REPO}/releases/latest"
    headers = {"Accept": "application/vnd.github+json"}
    token = st.secrets.get("github_token")

    if token:
        headers["Authorization"] = f"Bearer {token}"

    resp = requests.get(url, headers=headers)

    if resp.status_code == 200:
        release = resp.json()
        assets = release.get("assets", [])
        # ... (후술)
    else:
        handle_error(resp.status_code, resp.text)
    ```
    여기서 액세스 토큰은 `st.secrets`에 저장된 GitHub PAT 등을 사용하는데, 해당 토큰에 적절한 권한이 있어야 합니다(repo 권한 등). 퍼블릭 리포지토리의 경우 인증 없이도 호출이 가능하나, 레이트 리미트나 private repo 대비를 위해 토큰을 쓰는 것이 좋습니다.

-   **릴리스 자산 조회 및 다운로드:** `release["assets"]` 리스트에서 인덱스 zip 파일 자산을 찾아 다운로드합니다. 릴리스 JSON에는 각 자산별로 `browser_download_url` 필드가 있으며, 이를 사용해 파일을 직접 내려받을 수 있습니다. 일반적으로 하나의 최신 인덱스 자산만 있으므로, `assets[0]`를 가져와 처리하면 될 것입니다.
    ```python
    if assets:
        asset = assets[0]
        zip_url = asset["browser_download_url"]
        resp2 = requests.get(zip_url, stream=True)
        if resp2.status_code == 200:
            zip_bytes = resp2.content
            # zip 파싱 로직은 아래에서 계속
        else:
            handle_error(resp2.status_code, resp2.text)
    else:
        st.warning("릴리스에 인덱스 자산이 없습니다.")
    ```
    이때 `stream=True`로 받아와도 되고, 작은 파일이면 바로 `content`로 받아도 무방합니다.

-   **에러 처리:** 자산이 없을 경우 사용자에게 메시지를 표시하고 복원을 건너뛰도록 합니다. 다운로드 404 등의 오류도 예외로 처리합니다.

-   **Zip 파일 파싱 보완:** 다운로드한 바이트 데이터를 `zipfile.ZipFile`로 열어 내부 파일들을 지정된 persist 디렉토리(예: `~/.maic/persist`)에 풀어야 합니다. 이 때 다음 사항을 고려합니다:
    -   **예외 처리:** 잘못된 ZIP이거나 압축 해제 중 문제가 생길 경우를 대비해 `try/except`로 감싸고, 실패 시 사용자에게 오류를 알리되 앱이 죽지 않도록 합니다 (`st.error` 등으로 표시).
    -   **경로 구조:** ZIP 내부에 상위 폴더가 포함되어 있을 경우 (예: zip 안에 `persist/` 디렉토리가 들어있는 형태) 해당 구조를 인식하여 중복 디렉토리 생성을 피합니다. 예를 들어 `zip_ref.namelist()`를 확인해 상위에 폴더명이 공통으로 붙어있으면 그 부분을 제거하고 추출할 수 있습니다. 또는 `zip_ref.extractall(path)` 후, 추출된 하위 폴더 내 파일들을 실제 persist 경로로 옮기는 로직을 추가합니다.
    -   **파일 검사:** 추출 후 예상되는 주요 인덱스 파일들이 존재하는지 확인합니다 (예: 인덱스 메타데이터 `.json`이나 `.index` 파일 등). 누락된 경우 경고를 주고 복원 과정을 중단하거나, 필요시 대체 동작을 수행합니다.

    ```python
    import zipfile
    import io
    import os
    import shutil

    try:
        with zipfile.ZipFile(io.BytesIO(zip_bytes)) as zipf:
            # 만약 zip에 디렉토리 한 겹 씌워져 있으면 처리
            members = zipf.namelist()
            common_prefix = os.path.commonprefix(members)

            if common_prefix and common_prefix.endswith("/"):
                # ZIP이 폴더를 포함한 경우: 폴더명 제거
                for member in members:
                    dest_path = os.path.join(persist_dir, member[len(common_prefix):])
                    if member.endswith('/'):
                        os.makedirs(dest_path, exist_ok=True)
                    else:
                        with zipf.open(member) as source, open(dest_path, 'wb') as target:
                            shutil.copyfileobj(source, target)
            else:
                zipf.extractall(persist_dir)
    except Exception as e:
        st.error(f"인덱스 ZIP 파일 처리 중 오류가 발생했습니다: {e}")
        return
    ```
    위 로직은 ZIP 내부 구조에 유연하게 대응하여 파일을 추출합니다.

-   **GitHub API 오류 처리:** GitHub API 호출 시 404 이외에 토큰 권한 오류(401/403), 레이트리밋(예: 403 with rate limit info), 네트워크 장애 등의 경우도 고려합니다. 각 상황에 대해 사용자에게 친절한 메시지를 보여주고, 필요하면 재시도 안내를 합니다. 예를 들어 401/403이면 "GitHub 인증에 실패했습니다. 토큰을 확인하세요." 등을 출력하고, 레이트 리밋이면 "GitHub API 한도를 초과했습니다. 잠시 후 재시도 해주세요." 등을 표시할 수 있습니다. 이러한 예외는 `resp.status_code`를 분석하거나 `resp.headers`(특히 `X-RateLimit-Remaining`) 등을 참고하여 분기합니다.

-   **폴백(fallback) 로직:** 만약 GitHub에서 최신 인덱스를 가져오지 못한 경우(예: 릴리스가 아예 없음 또는 API 실패), 앱이 완전히 실패해서는 안 됩니다. 풀백 방안으로:
    -   **메시지 표시 및 종료:** 가장 간단히는 "원격 백업 인덱스가 없어 자동 복원을 건너뜁니다." 같은 정보를 알리고, 복원 프로세스를 빠져나옵니다. 이후 사용자(관리자)가 수동으로 인덱싱을 수행하게 유도합니다.
    -   **이전 릴리스 시도:** 조금 더 나아간다면, GitHub API의 `/releases` 목록을 불러와 최신 릴리스가 아니라 그 이전 릴리스라도 찾아볼 수 있습니다. 예를 들어 `requests.get(.../releases?per_page=5)`로 몇 개를 가져와 인덱스 자산이 있는 첫 릴리스를 찾는 방식입니다.
    -   **로컬 백업 사용:** 만약 앱이 이전 실행 시점에 로컬에 백업한 인덱스 파일을 가지고 있다면, 그것을 불러오는 방법도 고려할 수 있습니다. 예를 들어 마지막 성공 복원된 인덱스를 `maic/persist_backup` 등에 저장해 두었다면, 원격 복원 실패 시 그 백업으로 복구를 시도합니다.
    -   **전체 재색인:** 극단적인 경우 원격/로컬 어떤 인덱스도 사용할 수 없다면, 강제로 전체 인덱싱을 다시 수행하는 옵션을 제시할 수 있습니다. 예를 들어 "인덱스를 복원할 수 없어 전체 파일을 재색인합니다. 시간이 다소 걸릴 수 있습니다." 라고 안내한 후, 관리자에게 선택권을 주는 것이 좋습니다 (예: "복원 실패. [전체 인덱싱 실행]" 버튼 제공).

-   **동작 검증:** 수정 후에는 다음 시나리오를 테스트합니다:
    1.  GitHub에 `index-latest` 태그가 없는 상태에서 앱을 실행해보고, 최신 릴리스의 인덱스(zip)가 정상 다운로드 되어 복원되는지 확인.
    2.  의도적으로 잘못된 토큰/권한으로 설정하고 401/403 처리 경로 확인 (오류 메시지 노출 여부).
    3.  릴리스에 자산이 없거나 ZIP 내용이 예상과 다를 때 앱이 오류를 표출하되 죽지 않고 넘어가는지 확인.
    4.  네트워크를 끊은 상태에서 복원 버튼을 눌러보고 예외가 적절히 처리되는지 확인.
    5.  정상적인 경우와 오류 경우 모두에서 이후 워크플로우로 문제가 번지지 않는지 (예: `st.spinner` 종료 여부 등) 확인.

이상의 개선으로, GitHub 릴리스로부터 인덱스 복원 기능이 보다 견고해집니다.

---

## 3. 자연어 프롬프트의 YAML 스키마 자동 준수

**문제:**
Admin UI의 "한글 → LLM 정리 → YAML" 입력 탭에서 관리자가 한국어로 작성한 프롬프트를 넣으면, 이를 LLM이 요약/변환하여 YAML 스키마에 맞는 출력으로 내보내야 합니다. 그러나 현재 구현에서는 LLM 출력이 스키마와 일치하지 않아 YAML 파싱이나 검증 단계에서 실패하고, 결과적으로 출판(저장)에 실패하는 사례가 있습니다.

**해결 방안:**

-   **프롬프트 개선으로 정확한 출력 유도:** LLM에게 원하는 출력 스키마를 더 명시적으로 알리고, 반드시 해당 형식을 따르도록 지시합니다.
    -   **스키마 명세 제공:** 프롬프트에 "다음 YAML 스키마를 따르는 출력만 생성하세요:" 라고 지시하고, 필요한 필드들과 데이터 타입을 제시합니다.
    -   **예시 제공:** 올바른 YAML 예시를 하나 넣어두면 LLM이 그 형식을 따라하기 쉽습니다.
    -   **시스템 메시지 활용:** OpenAI API의 ChatCompletion 등을 쓴다면, `system` 메시지나 함수 호출 기능을 활용할 수 있습니다. OpenAl 함수 호출의 경우 함수의 매개변수를 JSON 스키마로 정의해주면, 모델이 자동으로 그 스키마에 맞는 JSON을 반환하도록 유도할 수 있습니다.

-   **LLM 정규화 체인 보완:** 현재 자연어 → YAML 변환을 한 번의 LLM 호출로 하고 있다면, 다중 단계 체인으로 개선을 고려합니다.
    1.  **초안 생성:** 우선 입력된 한국어 프롬프트를 기반으로 대략적인 YAML 초안을 생성합니다 (LLM 호출).
    2.  **포스트 프로세싱 & 검증:** 생성된 YAML 문자열을 파싱 (`yaml.safe_load`)하여 Python 딕셔너리로 변환한 뒤, 사전 정의된 스키마(Pydantic 모델 또는 `jsonschema` 등)로 검증합니다.
    3.  **수정 지시:** 검증에 통과하지 못하면, LLM에게 두 번째 호출로 교정 요청을 합니다. 이때 앞서 얻은 오류 피드백(예: "필수 필드 X가 없음")을 전달하며 수정을 요청합니다.
    4.  **최종 검증:** 수정된 출력이 다시 스키마를 만족하는지 확인합니다. 반복 횟수는 1~2회 내로 제한하여 무한 루프를 피합니다.

-   **자동 보정 로직:** 추가로, LLM 재호출 없이 코드 단에서 보정 가능한 부분은 자동 처리합니다.
    -   YAML 문자열에 불필요한 텍스트가 붙어있는 경우, 순수 YAML 부분만 추출합니다.
    -   누락된 선택적 필드에 대해 기본값을 채웁니다. (예: `data.setdefault('필드명', '기본값')`)
    -   필드의 타입이 잘못된 경우, 가능하면 변환을 시도합니다.

-   **스키마 검증 방식:** Pydantic의 모델을 정의해 `model.parse_obj(data)`로 검증하거나, `jsonschema`를 이용해 `jsonschema.validate(data, schema)` 하면 오류 경로와 원인을 명확하게 얻을 수 있습니다. 이 정보를 활용하면 LLM 교정 프롬프트를 만들기 수월해집니다.

-   **LangChain/기타 도구 활용:** LangChain의 `YamlOutputParser`나 `Guardrails AI` 같은 라이브러리를 도입하면 편리합니다. 이들은 Pydantic 기반 스키마를 제공하면 모델 출력이 자동으로 그 스키마에 맞게 파싱/검증되도록 도와줍니다.

-   **예외 처리:** 어떠한 경우에도 앱이 사용자 입력으로 인해 죽지 않도록 모든 오류를 `try/except`로 잡아내고, 사용자에게 "스키마에 맞는 출력 생성에 실패했습니다."와 같은 안내를 하고 프로세스를 중단합니다.

-   **적용 후 테스트:**
    -   관리자가 다양한 한글 프롬프트를 입력했을 때 모두 출판 완료까지 이어지는지 확인합니다.
    -   의도적으로 이상한 출력이 나오도록 LLM 프롬프트를 변조해보고 그래도 예외 없이 처리하거나 적절히 오류 표시하는지 확인합니다.
    -   스키마 요구사항이 변경되거나 필드 추가 시에도 유연하게 대처할 수 있는지 평가합니다.

이런 개선을 통해 자연어 프롬프트가 자동으로 스키마에 맞는 YAML로 정규화되며, 출판 프로세스의 안정성을 높일 수 있습니다.

---

## 4. 중복 코드 제거 및 불필요한 모듈/워크플로 정리

**문제:**
코드베이스 곳곳에 중복된 기능의 코드가 분산되어 있고, 사용되지 않거나 과거 버전의 잔재로 남은 파일과 로직이 있습니다. 이러한 중복과 불필요한 요소는 코드 유지보수를 어렵게 하고, 동작의 일관성을 해칠 수 있습니다.

**예상되는 중복/불필요 사례:**
-   동일한 역할을 하는 유틸리티 함수가 여러 모듈에 중복 정의된 경우.
-   과거 워크플로 파일들이 아직 프로젝트에 남아 있지만 현재 흐름에서는 참조되지 않는 경우.
-   데이터 구조나 설정을 다루는 코드가 여러 곳에 흩어져 있는 경우 (SSOT 위배).
-   기능상 유사한 클래스/함수가 이곳저곳에 존재해 DRY 원칙이 깨진 경우.

**해결 방안:**

-   **중복 코드 통합:** 리포지토리 전체를 훑어 유사한 동작을 하는 코드 조각들을 식별합니다.
    -   **함수 추출(Extract Method):** 한 파일 내 중복된 코드는 공통 함수를 만들고 둘 다 호출하도록 합니다.
    -   **유틸리티 모듈로 분리:** 서로 다른 파일/클래스에 있는 중복 로직은 `core/utils.py` 같은 공통 모듈로 분리하여 `import`하여 사용합니다. 이는 단일 진실 공급원(SSOT) 원칙을 지키는 데 도움이 됩니다.
    -   **함수 시그니처 통일:** 비슷한 함수가 미묘하게 다르게 구현되어 있다면, 기능을 병합하고 호출부를 모두 수정하여 새 통합 함수를 사용하도록 합니다.

-   **불필요한 코드 제거:** 프로젝트 구조를 점검하여 사용되지 않는 모듈이나 파일을 삭제합니다.
    -   각 파일이 어디서 `import`되거나 호출되는지 확인하고, 전혀 참조되지 않는다면 과감히 제거합니다 (Git history에 남아있으므로 복원 가능).
    -   더 이상 쓰이지 않는 `old_indexer.py`, standalone 스크립트, 실험용 노트북, 이전 버전 README 등도 정리 대상입니다.
    -   단, `.streamlit/secrets.toml` 등 현재 사용 중인 설정/시크릿 관련 파일은 유지해야 합니다.

-   **워크플로 단순화:** 중복되는 워크플로 단계도 통합합니다. 예를 들어 인덱싱을 트리거하는 경로가 여러 개 있다면, 이를 하나의 함수로 통일하고 각 UI 요소에서 그 함수를 호출하도록 합니다. 학습/관리자 모드 전환 로직이 분산되어 있다면 하나의 공용 함수(예: `set_mode('admin'|'student')`)로 합칩니다.

-   **테스트 및 검증:** 리팩터링 과정에서 기능 변경이 발생하지 않도록 반드시 기존 테스트를 모두 실행시켜 통과하는지 확인합니다. 통합 전후로 동작이 동일해야 하며, 커버되지 않은 부분은 수동으로 모든 페이지 기능을 실행해보고 콘솔 에러가 없는지 확인합니다.

-   **정리 효과:** 중복 코드를 제거하면 코드베이스가 짧고 명확해집니다. 구조가 단순화되고 유지보수 비용이 낮아지며, 새로운 기능 추가나 수정 시 일관성을 유지하기 쉽습니다.

---

**요약:**
이번 리팩터링을 통해 전반적인 앱의 구조를 개선하고, **사이드바 권한 제어**, **GitHub 연동 안정화**, **LLM 출력 안정화**, **코드 중복 제거**라는 네 가지 핵심 문제를 해결했습니다. 각 수정사항은 유기적으로 앱 품질을 향상시킵니다. 사이드바 제어로 권한별 UI 노출이 정확해졌고, GitHub 인덱스 복원은 신뢰성이 향상되었습니다. LLM 출력은 스키마 적합성을 보장받아 출판 과정이 원활해졌으며, 코드 정리는 가독성과 유지보수성을 높였습니다.

마지막으로, 이러한 변경을 모두 반영한 코드를 브랜치 `ui/refactor-orchestrator-20250918-b10`에 커밋하면 됩니다. 변경 범위가 넓으므로 의존하는 모듈들과의 호환성을 한 번 더 점검하고, 모든 기존 테스트 케이스를 통과시키는지 확인해야 합니다. 이제 한 번에 적용 가능한 형태로 리팩터링이 완료되었으므로, PR을 통해 코드베이스에 병합하고 배포 및 운영 단계에서 문제가 없는지 모니터링하면 될 것입니다.
