# 🏗️ 리포지토리 구조 최적화 계획

## 📊 현재 구조 분석

### 문제점
1. **모호한 폴더명**: `compat`, `runtime`, `state` 등 역할이 불분명
2. **기능 분산**: 관련 기능이 여러 폴더에 흩어져 있음
3. **의존성 복잡성**: import 경로가 직관적이지 않음
4. **문서화 부족**: 각 폴더의 역할이 명확하지 않음

### 현재 폴더별 역할 분석
- `admin/`: 관리자 기능 (API, UI)
- `agents/`: AI 에이전트 (평가, 응답, 파싱)
- `backup/`: 백업 및 패키징
- `common/`: 공통 유틸리티
- `compat/`: 호환성 브리지
- `core/`: 핵심 기능 (설정, 에러, 파일, 성능 등)
- `drive/`: Google Drive 연동
- `integrations/`: 외부 연동
- `llm/`: LLM 관련 (프로바이더, 스트리밍)
- `modes/`: 모드 관리 (프로파일, 라우터, 타입)
- `prompting/`: 프롬프트 관리 (소스, 타입)
- `rag/`: RAG 시스템 (엔진, 인덱스, 검색)
- `runtime/`: 런타임 (릴리스, 복원, 로더)
- `services/`: 서비스 (인덱스 액션, 상태)
- `state/`: 세션 상태
- `ui/`: 사용자 인터페이스
- `validation/`: 검증
- `vision/`: 비전 관련

## 🎯 제안하는 새로운 구조

### 계층별 역할 정의

#### 🎯 application/ - 애플리케이션 레이어
- **목적**: 사용자 요청을 처리하고 비즈니스 로직을 조율
- **폴더**:
  - `admin/`: 관리자 전용 기능
  - `chat/`: 채팅 인터페이스 및 대화 관리
  - `prompts/`: 프롬프트 생성, 편집, 배포

#### 🧠 domain/ - 도메인 로직
- **목적**: 핵심 비즈니스 로직과 도메인 모델
- **폴더**:
  - `ai_agents/`: AI 에이전트 구현 및 관리
  - `rag_system/`: RAG (Retrieval-Augmented Generation) 시스템
  - `knowledge_base/`: 지식 베이스 관리 및 검색

#### 🔧 infrastructure/ - 인프라 레이어
- **목적**: 외부 시스템과의 연동 및 기술적 구현
- **폴더**:
  - `external_apis/`: GitHub, Google Drive 등 외부 API 연동
  - `storage/`: 데이터 저장 및 관리
  - `monitoring/`: 로깅, 메트릭, 에러 추적

#### 🔗 shared/ - 공통 기능
- **목적**: 프로젝트 전반에서 사용되는 공통 기능
- **폴더**:
  - `utils/`: 유틸리티 함수 및 헬퍼
  - `config/`: 설정 관리 및 환경 변수
  - `security/`: 인증, 권한, 보안 관련 기능
  - `validation/`: 데이터 검증

#### 🎨 ui/ - 사용자 인터페이스
- **목적**: 사용자 인터페이스 관련 코드
- **폴더**:
  - `components/`: 재사용 가능한 UI 컴포넌트
  - `layouts/`: 페이지 레이아웃 및 구조
  - `styles/`: CSS, 테마, 스타일링
  - `widgets/`: 특수 위젯

## 📋 단계별 실행 계획

### Phase 1: 분석 및 준비 (1-2일)
1. **의존성 매핑**: 현재 import 관계 분석
2. **마이그레이션 계획**: 파일 이동 순서 결정
3. **백업 생성**: 현재 상태 백업
4. **브랜치 생성**: `feature/repo-structure-optimization`

### Phase 2: 폴더 구조 재정리 (3-4일)
1. **새 폴더 생성**: 새로운 구조에 맞는 폴더 생성
2. **파일 이동**: 단계별로 파일 이동
3. **Import 수정**: 모든 import 경로 업데이트
4. **테스트 업데이트**: 테스트 파일 경로 수정

### Phase 3: 문서화 및 표준화 (2-3일)
1. **README 작성**: 각 폴더별 README.md 생성
2. **API 문서**: 주요 함수/클래스 문서화
3. **아키텍처 다이어그램**: 구조 시각화
4. **코딩 표준**: 네이밍 컨벤션 문서화

### Phase 4: 검증 및 최적화 (1-2일)
1. **전체 테스트**: 모든 테스트 실행
2. **성능 검증**: 성능 저하 확인
3. **코드 리뷰**: 구조 개선점 검토
4. **최종 정리**: 불필요한 파일 정리

## 🎯 예상 효과

### 개발자 경험 개선
- **온보딩 시간 50% 단축**: 직관적인 구조로 빠른 이해
- **버그 수정 시간 단축**: 관련 코드 위치 파악 용이
- **기능 추가 효율성**: 어디에 추가할지 명확

### AI 친화성 향상
- **컨텍스트 이해 개선**: 폴더명으로 기능 추론 가능
- **코드 분석 정확도 향상**: 구조적 패턴 인식
- **자동화 가능성 증대**: 표준화된 구조로 자동화 용이

### 유지보수성 증대
- **의존성 관리**: 계층별 의존성 명확화
- **테스트 용이성**: 구조화된 테스트 작성
- **확장성**: 새로운 기능 추가 시 가이드라인 제공

## ⚠️ 리스크 관리

### 기술적 리스크
- **Import 경로 오류**: 단계별 검증으로 방지
- **순환 의존성**: 의존성 그래프 분석으로 방지
- **기능 손실**: 충분한 테스트로 방지

### 프로젝트 리스크
- **개발 중단**: 백업 및 롤백 계획으로 방지
- **팀 혼란**: 명확한 가이드라인 제공
- **일정 지연**: 단계별 진행으로 리스크 분산

## 📊 성공 지표

### 정량적 지표
- **Import 경로 길이**: 평균 30% 단축
- **폴더 깊이**: 최대 3단계로 제한
- **파일 분산도**: 관련 파일들의 응집도 향상

### 정성적 지표
- **개발자 만족도**: 구조 이해도 향상
- **코드 리뷰 효율성**: 리뷰 시간 단축
- **새 기능 개발 속도**: 개발 시간 단축

## 🚀 다음 단계

1. **현재 구조 상세 분석** 완료
2. **의존성 매핑** 시작
3. **마이그레이션 스크립트** 작성
4. **단계별 실행** 진행

---

*이 문서는 리포지토리 구조 최적화의 전체적인 계획을 담고 있습니다. 각 단계별로 상세한 실행 가이드가 제공됩니다.*
