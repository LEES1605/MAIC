# =============================== [01] future import â€” START ===========================
from __future__ import annotations
# ================================ [01] future import â€” END ============================

# =============================== [02] module imports â€” START ==========================
from typing import Any, Dict, List, Optional
import time
import json
import sys
try:
    import streamlit as st
except Exception:  # pragma: no cover
    st = None

from src.services.index_state import render_index_steps
from src.services.index_actions import (
    persist_dir_safe as _persist_dir_safe,
    make_index_backup_zip,
    upload_index_backup,
    run_admin_index_job,
)

# ë‚´ë¶€ ë™ì  ë¡œë”(ì•± ë„ìš°ë¯¸ ì ‘ê·¼)
def _resolve_app_attr(name: str):
    try:
        app_mod = sys.modules.get("__main__")
        return getattr(app_mod, name, None)
    except Exception:
        return None

# preparedìš© ë™ì  API ë¡œë”
def _load_prepared_lister():
    try:
        from src.services.index_actions import _load_prepared_lister as _lp
        return _lp()
    except Exception:
        return None, []

def _load_prepared_api():
    try:
        from src.services.index_actions import _load_prepared_api as _la
        return _la()
    except Exception:
        return None, None, []
# ================================ [02] module imports â€” END ===========================

# ì—ëŸ¬ ë¡œê¹… í•¨ìˆ˜
def _log_error(error_type: str, message: str, traceback_str: str | None = None):
    """ì—ëŸ¬ë¥¼ ì„¸ì…˜ ìƒíƒœì— ë¡œê¹…"""
    try:
        if "st" in globals() and st is not None:
            import time
            error_logs = st.session_state.get("_ERROR_LOGS", [])
            error_logs.append({
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "type": error_type,
                "message": message,
                "traceback": traceback_str
            })
            # ìµœëŒ€ 50ê°œ ì—ëŸ¬ë§Œ ìœ ì§€
            if len(error_logs) > 50:
                error_logs = error_logs[-50:]
            st.session_state["_ERROR_LOGS"] = error_logs
    except Exception:
        pass

# =============================== [03] orchestrator header â€” START =====================
def render_orchestrator_header() -> None:
    if st is None:
        return

    # ê³µìš© íŒì •ê¸°(ì—­í˜¸í™˜ í—ˆìš©)
    try:
        from src.core.readiness import is_ready_text, norm_ready_text
    except Exception:
        def _norm(x: str | bytes | None) -> str:
            if x is None:
                return ""
            if isinstance(x, bytes):
                x = x.decode("utf-8", "ignore")
            return x.replace("\ufeff", "").strip().lower()
        def is_ready_text(x):  # type: ignore
            return _norm(x) in {"ready", "ok", "true", "1", "on", "yes", "y", "green"}
        def norm_ready_text(x):  # type: ignore
            return _norm(x)

    st.markdown("### ğŸ§ª ì¸ë±ìŠ¤ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°")
    persist = _persist_dir_safe()
    with st.container():
        st.caption("Persist Dir")
        st.code(str(persist), language="text")

    # ë¡œì»¬ ì¤€ë¹„ ìƒíƒœ ì¬ê³„ì‚°(ì„¸ì…˜ í‚¤ ë³´ì •)
    cj = persist / "chunks.jsonl"
    rf = persist / ".ready"
    try:
        ready_txt = rf.read_text(encoding="utf-8") if rf.exists() else ""
    except Exception:
        ready_txt = ""
    local_ready = cj.exists() and cj.stat().st_size > 0 and is_ready_text(ready_txt)
    st.session_state["_INDEX_LOCAL_READY"] = bool(local_ready)

    # ìµœì‹  ì—¬ë¶€(í—¤ë” ì¹© ê²°ì •ìš©) â€” ì•± ì„¸ì…˜ í”Œë˜ê·¸ ì‚¬ìš©
    is_latest = bool(st.session_state.get("_INDEX_IS_LATEST", False))
    latest_tag = st.session_state.get("_LATEST_RELEASE_TAG")

    # ì¹© ê³„ì‚° (ì‹¤ì œ íŒŒì¼ ìƒíƒœì™€ ì„¸ì…˜ ìƒíƒœ ëª¨ë‘ ê³ ë ¤)
    if is_latest and local_ready:
        badge = "ğŸŸ© ì¤€ë¹„ì™„ë£Œ"
        badge_code = "READY"
        badge_desc = f"ìµœì‹  ë¦´ë¦¬ìŠ¤ ì ìš©ë¨ (tag={latest_tag})" if latest_tag else "ìµœì‹  ë¦´ë¦¬ìŠ¤ ì ìš©ë¨"
    elif local_ready:
        badge = "ğŸŸ¨ ì¤€ë¹„ì¤‘(ë¡œì»¬ ì¸ë±ìŠ¤ ê°ì§€)"
        badge_code = "MISSING"
        badge_desc = "ë¡œì»¬ ì¸ë±ìŠ¤ëŠ” ìˆìœ¼ë‚˜ ìµœì‹  ë¦´ë¦¬ìŠ¤ì™€ ë¶ˆì¼ì¹˜ ë˜ëŠ” ë¯¸í™•ì¸"
    elif is_latest and not local_ready:
        badge = "ğŸŸ§ ì„¸ì…˜ ë¶ˆì¼ì¹˜"
        badge_code = "MISSING"
        badge_desc = "ì„¸ì…˜ì—ì„œëŠ” ìµœì‹ ì´ì§€ë§Œ ì‹¤ì œ íŒŒì¼ì´ ì—†ê±°ë‚˜ ì†ìƒë¨"
    else:
        badge = "ğŸŸ§ ì—†ìŒ"
        badge_code = "MISSING"
        badge_desc = "ì¸ë±ìŠ¤ ì—†ìŒ"

    # iOS ìŠ¤íƒ€ì¼ + ë¯¸ë‹ˆë©€ë¦¬ì¦˜ ë””ìì¸ ì ìš©
    if bool(st.session_state.get("admin_mode", False)):
        # ìë™ ìŠ¤ìº” ìƒíƒœ í‘œì‹œ (ê´€ë¦¬ì ì „ìš©) - iOS ìŠ¤íƒ€ì¼
        boot_scan_done = st.session_state.get("_BOOT_SCAN_DONE", False)
        has_new_files = st.session_state.get("_PREPARED_HAS_NEW", False)
        new_files_count = st.session_state.get("_PREPARED_NEW_FILES", 0)
        total_files_count = st.session_state.get("_PREPARED_TOTAL_FILES", 0)
        
        # iOS ìŠ¤íƒ€ì¼ ìƒíƒœ í‘œì‹œ CSS
        st.markdown("""
        <style>
        .ios-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 20px 0;
            background: #f2f2f7;
            border-radius: 12px;
            padding: 16px;
        }
        .ios-status-card {
            background: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1f;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .ios-status-icon {
            font-size: 18px;
            margin-bottom: 4px;
            color: #007aff;
        }
        .ios-status-text {
            font-size: 12px;
            color: #8e8e93;
            margin-top: 2px;
        }
        
        /* ëª¨ë°”ì¼ ìµœì í™” */
        @media (max-width: 768px) {
            .ios-status-grid {
                grid-template-columns: 1fr;
                gap: 8px;
                margin: 16px 0;
                padding: 12px;
            }
            .ios-status-card {
                padding: 16px 12px;
                min-height: 48px;
                font-size: 16px;
            }
            .ios-status-icon {
                font-size: 20px;
            }
            .ios-status-text {
                font-size: 14px;
            }
        }
        </style>
        """, unsafe_allow_html=True)
        
        # iOS ìŠ¤íƒ€ì¼ ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
        status_html = '<div class="ios-status-grid">'
        
        # ì¸ë±ìŠ¤ ìƒíƒœ (ë¬´ì±„ìƒ‰ ì•„ì´ì½˜)
        if local_ready and is_latest:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">â—</div>
                <div>ì¤€ë¹„ì™„ë£Œ</div>
                <div class="ios-status-text">ìµœì‹  ë¦´ë¦¬ìŠ¤</div>
            </div>
            '''
        elif local_ready:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">â—‹</div>
                <div>ë¡œì»¬ì‚¬ìš©</div>
                <div class="ios-status-text">ë³µì› í•„ìš”</div>
            </div>
            '''
        else:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">â—‹</div>
                <div>ë³µì›í•„ìš”</div>
                <div class="ios-status-text">ì¸ë±ìŠ¤ ì—†ìŒ</div>
            </div>
            '''
        
        # ìŠ¤ìº” ìƒíƒœ (ë¬´ì±„ìƒ‰ ì•„ì´ì½˜)
        if boot_scan_done:
            if has_new_files:
                status_html += f'''
                <div class="ios-status-card">
                    <div class="ios-status-icon">â—‹</div>
                    <div>ìƒˆíŒŒì¼ {new_files_count}ê°œ</div>
                    <div class="ios-status-text">ì—…ë°ì´íŠ¸ í•„ìš”</div>
                </div>
                '''
            else:
                status_html += '''
                <div class="ios-status-card">
                    <div class="ios-status-icon">â—</div>
                    <div>ìµœì‹ </div>
                    <div class="ios-status-text">ë™ê¸°í™” ì™„ë£Œ</div>
                </div>
                '''
        else:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">â—</div>
                <div>ìŠ¤ìº”ì¤‘</div>
                <div class="ios-status-text">ì²˜ë¦¬ ì¤‘</div>
            </div>
            '''
        
        # íŒŒì¼ ìˆ˜ í‘œì‹œ
        status_html += f'''
        <div class="ios-status-card">
            <div class="ios-status-icon">â—‹</div>
            <div>{total_files_count}ê°œ</div>
            <div class="ios-status-text">ì´ íŒŒì¼</div>
        </div>
        '''
        
        status_html += '</div>'
        st.markdown(status_html, unsafe_allow_html=True)
        
        # ë³µì› ìƒíƒœ í‘œì‹œ ì œê±° (ë¯¸ë‹ˆë©€ë¦¬ì¦˜)
        # ë³µì› ìƒíƒœëŠ” ì‹œìŠ¤í…œ ìƒíƒœ ì¹´ë“œì—ì„œ ì¶©ë¶„íˆ í‘œì‹œë¨
        
        # iOS ìŠ¤íƒ€ì¼ ë²„íŠ¼ CSS ì¶”ê°€
        st.markdown("""
        <style>
        .ios-button {
            background: #ffffff;
            border: 1px solid #d1d1d6;
            border-radius: 10px;
            padding: 16px 20px;
            font-size: 16px;
            font-weight: 500;
            color: #007aff;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .ios-button:hover {
            background: #f2f2f7;
            border-color: #007aff;
        }
        .ios-button.primary {
            background: #007aff;
            color: #ffffff;
            border-color: #007aff;
        }
        .ios-button.primary:hover {
            background: #0056cc;
        }
        .ios-button-icon {
            font-size: 18px;
            color: inherit;
        }
        
        /* ëª¨ë°”ì¼ ìµœì í™” */
        @media (max-width: 768px) {
            .ios-button {
                padding: 20px 24px;
                font-size: 17px;
                min-height: 52px;
            }
            .ios-button-icon {
                font-size: 20px;
            }
        }
        </style>
        """, unsafe_allow_html=True)
        
        # ì£¼ìš” ì‘ì—… ì„¹ì…˜
        st.markdown("#### ì£¼ìš” ì‘ì—…")
        
        main_col1, main_col2 = st.columns([1, 1])
        
        with main_col1:
            if st.button("ì¸ë±ì‹± & ì—…ë¡œë“œ", use_container_width=True, type="primary"):
                params = {"auto_up": True, "debug": bool(show_debug)}
                try:
                    run_admin_index_job(params)
                except Exception as e:
                    st.error(f"ê°•ì œ ì¸ë±ì‹± ì‹¤íŒ¨: {e}")
        
        with main_col2:
            if st.button("Release ì—…ë¡œë“œ", use_container_width=True):
                try:
                    used_persist = _persist_dir_safe()
                    z = make_index_backup_zip(used_persist)
                    msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                    st.success(f"Release ì—…ë¡œë“œ ì™„ë£Œ: {msg}")
                except Exception as e:
                    st.error(f"Release ì—…ë¡œë“œ ì‹¤íŒ¨: {e}")
        
        # ê´€ë¦¬ ë„êµ¬ ì„¹ì…˜
        st.markdown("#### ê´€ë¦¬ ë„êµ¬")
        
        # 2x2 ê·¸ë¦¬ë“œë¡œ ê´€ë¦¬ ë„êµ¬ ë²„íŠ¼ë“¤ ë°°ì¹˜
        tool_col1, tool_col2 = st.columns([1, 1])
        
        with tool_col1:
            if st.button("íŒŒì¼ìŠ¤ìº”", use_container_width=True):
                try:
                    # ìˆ˜ë™ ìŠ¤ìº” ì‹¤í–‰
                    lister, _ = _load_prepared_lister()
                    if lister:
                        files_list = lister() or []
                        chk, _mark, _ = _load_prepared_api()
                        new_files = []
                        if callable(chk):
                            try:
                                persist_dir = _persist_dir_safe()
                                info = chk(persist_dir, files_list) or {}
                                new_files = list(info.get("files") or info.get("new") or [])
                            except Exception as e:
                                st.error(f"ìŠ¤ìº” ì‹¤í–‰ ì‹¤íŒ¨: {e}")
                                return
                        
                        total_files = len(files_list)
                        new_count = len(new_files)
                        
                        if new_count > 0:
                            st.warning(f"ğŸ†• ìƒˆ íŒŒì¼ {new_count}ê°œ ë°œê²¬! (ì´ {total_files}ê°œ íŒŒì¼)")
                            st.session_state["_PREPARED_HAS_NEW"] = True
                            st.session_state["_PREPARED_NEW_FILES"] = new_count
                        else:
                            st.success(f"âœ… ìƒˆ íŒŒì¼ ì—†ìŒ (ì´ {total_files}ê°œ íŒŒì¼)")
                            st.session_state["_PREPARED_HAS_NEW"] = False
                    else:
                        st.error("prepared í´ë” ì ‘ê·¼ ë¶ˆê°€")
                except Exception as e:
                    st.error(f"ìŠ¤ìº” ì‹¤íŒ¨: {e}")
                    import traceback
                    _log_error("ìŠ¤ìº” ì‹¤íŒ¨", str(e), traceback.format_exc())
        
        with idx_col2:
            if st.button("âœ… ê²€ì¦", use_container_width=True, key="validation_btn"):
                try:
                    # ì‹¤ì‹œê°„ìœ¼ë¡œ íŒŒì¼ ìƒíƒœ ì¬í™•ì¸ (ì„¸ì…˜ ìƒíƒœì™€ ë¬´ê´€í•˜ê²Œ)
                    cj_exists = cj.exists()
                    cj_size = cj.stat().st_size if cj_exists else 0
                    cj_valid = cj_exists and cj_size > 0
                    
                    rf_exists = rf.exists()
                    try:
                        current_ready_txt = rf.read_text(encoding="utf-8") if rf_exists else ""
                    except Exception as e:
                        current_ready_txt = f"<ì½ê¸°ì˜¤ë¥˜: {e}>"
                    
                    ready_valid = is_ready_text(current_ready_txt)
                    current_local_ready = cj_valid and ready_valid
                    
                    ok = current_local_ready
                    if ok:
                        st.success("ê²€ì¦ ì„±ê³µ: chunks.jsonl ì¡´ì¬ & .ready ìœ íš¨")
                    else:
                        st.error("ê²€ì¦ ì‹¤íŒ¨: ì‚°ì¶œë¬¼/ready ìƒíƒœê°€ ë¶ˆì¼ì¹˜")
                except Exception as e:
                    st.error(f"ê²€ì¦ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("ê²€ì¦ ì‹¤íŒ¨", str(e), traceback_str)
        
        # ë¦´ë¦¬ìŠ¤ ê´€ë ¨ ë„êµ¬
        st.markdown("#### ğŸ“¤ ë¦´ë¦¬ìŠ¤ ê´€ë ¨")
        
        rel_col1, rel_col2 = st.columns([1, 1])
        
        with rel_col1:
            if st.button("ğŸ”„ ë¦´ë¦¬ìŠ¤ë³µì›", use_container_width=True, type="primary"):
                try:
                    # ê°•ì œ ë³µì› í”Œë˜ê·¸ ì„¤ì •
                    st.session_state["_FORCE_RESTORE"] = True
                
                    # ë³µì› ì „ ìƒíƒœ ê¸°ë¡
                    pre_restore_state = {
                        "chunks_exists": cj.exists(),
                        "chunks_size": cj.stat().st_size if cj.exists() else 0,
                        "ready_exists": rf.exists(),
                        "ready_content": rf.read_text(encoding="utf-8") if rf.exists() else "",
                        "persist_files": [str(f) for f in persist.iterdir()] if persist.exists() else []
                    }
                    
                    fn = _resolve_app_attr("_boot_auto_restore_index")
                    if callable(fn):
                        try:
                            fn()
                        except Exception as restore_error:
                            st.error(f"ë³µì› ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {restore_error}")
                            import traceback
                            st.code(traceback.format_exc())
                            raise
                    
                    # ë³µì› í›„ ìƒíƒœ ê¸°ë¡
                    post_restore_state = {
                        "chunks_exists": cj.exists(),
                        "chunks_size": cj.stat().st_size if cj.exists() else 0,
                        "ready_exists": rf.exists(),
                        "ready_content": rf.read_text(encoding="utf-8") if rf.exists() else "",
                        "persist_files": [str(f) for f in persist.iterdir()] if persist.exists() else []
                    }
                    
                    # ë³µì› ê²°ê³¼ ì €ì¥
                    st.session_state["_RESTORE_DEBUG"] = {
                        "pre_restore": pre_restore_state,
                        "post_restore": post_restore_state,
                        "timestamp": int(time.time())
                    }
                    
                    st.success("Release ë³µì›ì„ ì‹œë„í–ˆìŠµë‹ˆë‹¤. ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.")
                except Exception as e:
                    st.error(f"ë³µì› ì‹¤í–‰ ì‹¤íŒ¨: {e}")
                    st.session_state["_FORCE_RESTORE"] = False  # í”Œë˜ê·¸ ë¦¬ì…‹
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("ë³µì› ì‹¤íŒ¨", str(e), traceback_str)

        with rel_col2:
            if st.button("ğŸ’¾ ë¡œì»¬ë³µì›", use_container_width=True):
                try:
                    from src.runtime.local_restore import find_local_backups, restore_from_local_backup
                    
                    # ë¡œì»¬ ë°±ì—… ì°¾ê¸°
                    from pathlib import Path
                    backup_base = Path.home() / ".maic"
                    backups = find_local_backups(backup_base)
                    
                    if not backups:
                        st.warning("ë¡œì»¬ ë°±ì—…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                        st.info("ë°±ì—… ìœ„ì¹˜: ~/.maic/backup, ~/.maic/backups, ~/.maic/index_backup ë“±")
                    else:
                        st.write(f"**ë°œê²¬ëœ ë°±ì—… ({len(backups)}ê°œ):**")
                        
                        # ë°±ì—… ëª©ë¡ í‘œì‹œ
                        for i, backup in enumerate(backups[:5]):  # ìµœëŒ€ 5ê°œë§Œ í‘œì‹œ
                            backup_info = {
                                "path": str(backup),
                                "type": "ë””ë ‰í„°ë¦¬" if backup.is_dir() else "ì••ì¶•íŒŒì¼",
                                "size": f"{backup.stat().st_size / 1024 / 1024:.1f}MB" if backup.is_file() else "N/A"
                            }
                            st.write(f"{i+1}. {backup_info['type']}: {backup.name}")
                        
                        # ì²« ë²ˆì§¸ ë°±ì—…ìœ¼ë¡œ ë³µì› ì‹œë„
                        success, message = restore_from_local_backup(backups[0], persist)
                        
                        if success:
                            st.success(f"âœ… {message}")
                            # ì„¸ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸
                            st.session_state["_INDEX_LOCAL_READY"] = True
                            st.session_state["_INDEX_IS_LATEST"] = False  # ë¡œì»¬ ë³µì›ì´ë¯€ë¡œ ìµœì‹  ì•„ë‹˜
                            st.rerun()
                        else:
                            st.error(f"âŒ {message}")
                
                except Exception as e:
                    st.error(f"ë¡œì»¬ ë³µì› ì‹¤íŒ¨: {e}")
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("ë¡œì»¬ ë³µì› ì‹¤íŒ¨", str(e), traceback_str)

        with st.expander("ìµœê·¼ ê²€ì¦/ë³µì› ê¸°ë¡", expanded=False):
            rec = st.session_state.get("_LAST_RESTORE_CHECK")
            st.json(rec or {"hint": "ìœ„ì˜ ë³µì›/ê²€ì¦ ë²„íŠ¼ì„ ì‚¬ìš©í•´ ê¸°ë¡ì„ ë‚¨ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."})

        with st.expander("â„¹ï¸ ìµœì‹  ë¦´ë¦¬ìŠ¤/ë©”íƒ€ ì •ë³´", expanded=False):
            st.write({
                "latest_release_tag": latest_tag,
                "latest_release_id": st.session_state.get("_LATEST_RELEASE_ID"),
                "last_restore_meta": st.session_state.get("_LAST_RESTORE_META"),
                "is_latest": is_latest,
                "local_ready": local_ready,
            })
            
        # ë³µì› ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ
        restore_debug = st.session_state.get("_RESTORE_DEBUG")
        if restore_debug:
            with st.expander("ğŸ”§ ë³µì› ë””ë²„ê·¸ ì •ë³´", expanded=True):
                st.json(restore_debug)
        
        # ì—ëŸ¬ íŒ¨ë„ ì¶”ê°€
        st.markdown("#### ğŸš¨ ì—ëŸ¬ ë¡œê·¸")
        error_logs = st.session_state.get("_ERROR_LOGS", [])
        
        if error_logs:
            # ìµœê·¼ ì—ëŸ¬ 5ê°œë§Œ í‘œì‹œ
            recent_errors = error_logs[-5:]
            for i, error in enumerate(reversed(recent_errors)):
                with st.expander(f"ì—ëŸ¬ {len(error_logs) - i}: {error.get('timestamp', 'Unknown')}", expanded=(i == 0)):
                    st.error(f"**íƒ€ì…**: {error.get('type', 'Unknown')}")
                    st.error(f"**ë©”ì‹œì§€**: {error.get('message', 'No message')}")
                    if error.get('traceback'):
                        st.code(error['traceback'], language='python')
                    
                    # ë³µì‚¬ ë²„íŠ¼
                    if st.button(f"ğŸ“‹ ì—ëŸ¬ {len(error_logs) - i} ë³µì‚¬", key=f"copy_error_{i}"):
                        error_text = f"ì—ëŸ¬ íƒ€ì…: {error.get('type', 'Unknown')}\n"
                        error_text += f"ì—ëŸ¬ ë©”ì‹œì§€: {error.get('message', 'No message')}\n"
                        if error.get('traceback'):
                            error_text += f"ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:\n{error['traceback']}"
                        st.code(error_text, language='text')
                        st.success("ì—ëŸ¬ ë‚´ìš©ì´ ìœ„ì— í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”.")
        else:
            st.info("ì—ëŸ¬ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
        
        # ì—ëŸ¬ ë¡œê·¸ ì´ˆê¸°í™” ë²„íŠ¼
        if st.button("ğŸ—‘ï¸ ì—ëŸ¬ ë¡œê·¸ ì´ˆê¸°í™”", use_container_width=True):
            st.session_state["_ERROR_LOGS"] = []
            st.success("ì—ëŸ¬ ë¡œê·¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
            st.rerun()
        
        # ë¦´ë¦¬ìŠ¤ ìì‚° ì •ë³´ í™•ì¸ ë²„íŠ¼ ì¶”ê°€
        if st.button("ğŸ” ë¦´ë¦¬ìŠ¤ ìì‚° ì •ë³´ í™•ì¸", use_container_width=True):
            try:
                from src.runtime.gh_release import GHConfig, GHReleases
                import os
                
                # GitHub ì„¤ì •
                repo_full = st.secrets.get("GITHUB_REPO", os.getenv("GITHUB_REPO", ""))
                token = st.secrets.get("GITHUB_TOKEN", os.getenv("GITHUB_TOKEN"))
                
                if "/" not in str(repo_full):
                    st.error("GITHUB_REPO ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.")
                    return
                
                owner, repo = str(repo_full).split("/", 1)
                gh = GHReleases(GHConfig(owner=owner, repo=repo, token=token))
                
                # ìµœì‹  ë¦´ë¦¬ìŠ¤ ì •ë³´ ì¡°íšŒ
                latest_rel = gh.get_latest_release()
                if latest_rel:
                    st.success(f"ìµœì‹  ë¦´ë¦¬ìŠ¤: {latest_rel.get('tag_name')}")
                    assets = latest_rel.get("assets", [])
                    if assets:
                        st.write("**ìì‚° ëª©ë¡:**")
                        for asset in assets:
                            st.write(f"- {asset.get('name')} ({asset.get('size', 0)} bytes)")
                    else:
                        st.warning("ìì‚°ì´ ì—†ìŠµë‹ˆë‹¤.")
                else:
                    st.error("ë¦´ë¦¬ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                    
            except Exception as e:
                st.error(f"ë¦´ë¦¬ìŠ¤ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                import traceback
                st.code(traceback.format_exc())

        try:
            _dbg = _resolve_app_attr("_render_release_candidates_debug")
            if callable(_dbg):
                _dbg()
        except Exception:
            pass

    # í•™ìƒ í™”ë©´ì—ì„œëŠ” ê°„ë‹¨í•œ ìƒíƒœë§Œ í‘œì‹œ
    local_ready = st.session_state.get("_INDEX_LOCAL_READY", False)
    is_latest = st.session_state.get("_INDEX_IS_LATEST", False)
    
    if local_ready and is_latest:
        st.success("âœ… ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ", icon="âœ…")
    elif local_ready:
        st.warning("âš ï¸ ë¡œì»¬ ì¸ë±ìŠ¤ ì‚¬ìš© ì¤‘ (ìµœì‹  ì•„ë‹˜)", icon="âš ï¸")
    else:
        st.error("âŒ ì¸ë±ìŠ¤ ì—†ìŒ - ê´€ë¦¬ì ëª¨ë“œì—ì„œ ë³µì›í•˜ì„¸ìš”", icon="âŒ")
    
    st.info(
        "ê´€ë¦¬ì ëª¨ë“œì—ì„œ ì¸ë±ìŠ¤ ê´€ë¦¬, ìŠ¤ìº”, ì¬ì¸ë±ì‹±ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        icon="â„¹ï¸",
    )
    st.markdown("<span id='idx-admin-panel'></span>", unsafe_allow_html=True)
# ================================ [03] orchestrator header â€” END ======================

# =============================== [04] prepared scan â€” START ===========================
def render_prepared_scan_panel() -> None:
    if st is None or not bool(st.session_state.get("admin_mode", False)):
        return

    st.markdown("<h4>ğŸ” ìƒˆ íŒŒì¼ ìŠ¤ìº”(ì¸ë±ì‹± ì—†ì´)</h4>", unsafe_allow_html=True)

    c1, c2, _c3 = st.columns([1, 1, 2])
    act_scan = c1.button("ğŸ” ìŠ¤ìº” ì‹¤í–‰", use_container_width=True)
    act_clear = c2.button("ğŸ§¹ í™”ë©´ ì§€ìš°ê¸°", use_container_width=True)

    if act_clear:
        st.session_state.pop("_PR_SCAN_RESULT", None)
        try:
            _sr = _resolve_app_attr("_safe_rerun")
            if callable(_sr):
                _sr("pr_scan_clear", ttl=1)
        except Exception:
            pass

    prev = st.session_state.get("_PR_SCAN_RESULT")
    if isinstance(prev, dict) and not act_scan:
        st.caption("ì´ì „ì— ì‹¤í–‰í•œ ìŠ¤ìº” ê²°ê³¼:")
        st.json(prev)

    if not act_scan:
        return

    idx_persist = _persist_dir_safe()
    lister, dbg1 = _load_prepared_lister()
    files_list: List[Dict[str, Any]] = []
    if lister:
        try:
            files_list = lister() or []
        except Exception as e:
            st.error(f"prepared ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {e}")
    else:
        with st.expander("ë””ë²„ê·¸(íŒŒì¼ ë‚˜ì—´ í•¨ìˆ˜ ë¡œë“œ ê²½ë¡œ)"):
            st.write("\n".join(dbg1) or "(ì •ë³´ ì—†ìŒ)")

    chk, _mark, dbg2 = _load_prepared_api()
    info: Dict[str, Any] = {}
    new_files: List[str] = []
    if callable(chk):
        try:
            info = chk(idx_persist, files_list) or {}
        except TypeError:
            info = chk(idx_persist) or {}
        except Exception as e:
            st.error(f"ìŠ¤ìº” ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            info = {}
        try:
            new_files = list(info.get("files") or info.get("new") or [])
        except Exception:
            new_files = []
    else:
        with st.expander("ë””ë²„ê·¸(ì†Œë¹„ API ë¡œë“œ ê²½ë¡œ)"):
            st.write("\n".join(dbg2) or "(ì •ë³´ ì—†ìŒ)")

    total_prepared = len(files_list)
    total_new = len(new_files)
    st.success(f"ìŠ¤ìº” ì™„ë£Œ Â· prepared ì´ {total_prepared}ê±´ Â· ìƒˆ íŒŒì¼ {total_new}ê±´")

    if total_new:
        with st.expander("ìƒˆ íŒŒì¼ ë¯¸ë¦¬ë³´ê¸°(ìµœëŒ€ 50ê°œ)"):
            rows = []
            for rec in (new_files[:50] if isinstance(new_files, list) else []):
                if isinstance(rec, str):
                    rows.append({"name": rec})
                elif isinstance(rec, dict):
                    nm = str(rec.get("name") or rec.get("path") or rec.get("file") or "")
                    fid = str(rec.get("id") or rec.get("fileId") or "")
                    rows.append({"name": nm, "id": fid})
            if rows:
                st.dataframe(rows, hide_index=True, use_container_width=True)
            else:
                st.write("(í‘œì‹œí•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.)")
    else:
        st.info("ìƒˆ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ì¬ì¸ë±ì‹±ì„ ìˆ˜í–‰í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.")

    st.session_state["_PR_SCAN_RESULT"] = {
        "persist": str(idx_persist),
        "prepared_total": total_prepared,
        "new_total": total_new,
        "timestamp": int(time.time()),
        "sample_new": new_files[:10] if isinstance(new_files, list) else [],
    }
# ================================ [04] prepared scan â€” END ============================

def render_index_panel() -> None:
    """ê´€ë¦¬ì ì¸ë±ì‹± íŒ¨ë„ ë³¸ë¬¸."""
    if st is None:
        return

    st.markdown("### ğŸ”§ ê´€ë¦¬ì ì¸ë±ì‹± íŒ¨ë„ (prepared ì „ìš©)")

    # 2) ì˜µì…˜/ë²„íŠ¼ ì˜ì—­
    colA, colB = st.columns([1, 1])
    with colA:
        show_debug = st.toggle("ë””ë²„ê·¸ ë¡œê·¸ í‘œì‹œ", value=True, key="idx_show_debug")
    with colB:
        if st.button("ğŸ“¤ Releaseë¡œ ì—…ë¡œë“œ", use_container_width=True, key="idx_manual_upload"):
            try:
                used_persist = _persist_dir_safe()
                z = make_index_backup_zip(used_persist)
                msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                st.success(f"ì—…ë¡œë“œ ì™„ë£Œ: {msg}")
            except Exception as e:
                st.error(f"ì—…ë¡œë“œ ì‹¤íŒ¨: {e}")

    # 4) ì¸ë±ì‹± ë° ì—…ë¡œë“œ ë²„íŠ¼ë“¤ (ë‚˜ë€íˆ ë°°ì—´)
    col1, col2 = st.columns([1, 1])
    
    with col1:
        if st.button("ğŸš€ ì¸ë±ì‹± ë° ì—…ë¡œë“œ", type="primary",
                     use_container_width=True, key="idx_run_btn"):
            params = {"auto_up": True, "debug": bool(show_debug)}
            try:
                run_admin_index_job(params)
            except Exception as e:
                st.error(f"ê°•ì œ ì¸ë±ì‹± ì‹¤íŒ¨: {e}")
    
    with col2:
        if st.button("ğŸ“¤ Release ì—…ë¡œë“œ", type="secondary",
                     use_container_width=True, key="release_upload_btn"):
            try:
                used_persist = _persist_dir_safe()
                z = make_index_backup_zip(used_persist)
                msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                st.success(f"Release ì—…ë¡œë“œ ì™„ë£Œ: {msg}")
            except Exception as e:
                st.error(f"Release ì—…ë¡œë“œ ì‹¤íŒ¨: {e}")

    # 5) ë§ˆì§€ë§‰ìœ¼ë¡œ í•œ ë²ˆ ë” ì§„í–‰/ìƒíƒœ ë Œë”(ê´€ë¦¬ì ëª¨ë“œì—ì„œë§Œ)
    if bool(st.session_state.get("admin_mode", False)):
        try:
            render_index_steps()
        except Exception:
            pass
# ================================ [05] indexing panel â€” END ===========================

# =============================== [06] indexed sources â€” START =========================
def render_indexed_sources_panel() -> None:
    if st is None or not bool(st.session_state.get("admin_mode", False)):
        return

    chunks_path = _persist_dir_safe() / "chunks.jsonl"
    with st.container(border=True):
        st.subheader("ğŸ“„ ì¸ë±ì‹±ëœ íŒŒì¼ ëª©ë¡ (ì½ê¸° ì „ìš©)")
        # persist Dir ê²½ë¡œ í‘œì‹œ ì œê±° (ë¯¸ë‹ˆë©€ë¦¬ì¦˜)

        if not chunks_path.exists():
            st.info("ì•„ì§ ì¸ë±ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì¸ë±ì‹±ì„ ìˆ˜í–‰í•´ ì£¼ì„¸ìš”.")
            return

        docs: Dict[str, Dict[str, Any]] = {}
        total_lines = 0
        parse_errors = 0
        try:
            with chunks_path.open("r", encoding="utf-8") as rf:
                for line in rf:
                    s = line.strip()
                    if not s:
                        continue
                    total_lines += 1
                    try:
                        obj = json.loads(s)
                    except Exception:
                        parse_errors += 1
                        continue
                    doc_id = str(obj.get("doc_id") or obj.get("source") or "")
                    title = str(obj.get("title") or "")
                    source = str(obj.get("source") or "")
                    if not doc_id:
                        continue
                    row = docs.setdefault(
                        doc_id, {"doc_id": doc_id, "title": title, "source": source, "chunks": 0}
                    )
                    row["chunks"] += 1
        except Exception as e:
            try:
                _err = _resolve_app_attr("_errlog")
                if callable(_err):
                    _err(f"read chunks.jsonl failed: {e}", where="[indexed-sources.read]", exc=e)
            except Exception:
                pass
            st.error("ì¸ë±ìŠ¤ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.")
            return

        rows2 = [
            {"title": r["title"], "path": r["source"], "doc_id": r["doc_id"], "chunks": r["chunks"]}
            for r in docs.values()
        ]
        st.caption(
            f"ì´ ì²­í¬ ìˆ˜: {total_lines} Â· ë¬¸ì„œ ìˆ˜: {len(rows2)} (íŒŒì‹±ì˜¤ë¥˜ {parse_errors}ê±´)"
        )
        st.dataframe(rows2, hide_index=True, use_container_width=True)
# ================================ [06] indexed sources â€” END ==========================
