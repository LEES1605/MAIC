# =============================== [01] future import — START ===========================
from __future__ import annotations
# ================================ [01] future import — END ============================

# =============================== [02] module imports — START ==========================
from typing import Any, Dict, List, Optional
import time
import json
import sys
try:
    import streamlit as st
except Exception:  # pragma: no cover
    st = None

from src.services.index_state import render_index_steps
from src.services.index_actions import (
    persist_dir_safe as _persist_dir_safe,
    make_index_backup_zip,
    upload_index_backup,
    run_admin_index_job,
)

# 내부 동적 로더(앱 도우미 접근)
def _resolve_app_attr(name: str):
    try:
        app_mod = sys.modules.get("__main__")
        return getattr(app_mod, name, None)
    except Exception:
        return None

# prepared용 동적 API 로더
def _load_prepared_lister():
    try:
        from src.services.index_actions import _load_prepared_lister as _lp
        return _lp()
    except Exception:
        return None, []

def _load_prepared_api():
    try:
        from src.services.index_actions import _load_prepared_api as _la
        return _la()
    except Exception:
        return None, None, []
# ================================ [02] module imports — END ===========================

# 에러 로깅 함수
def _log_error(error_type: str, message: str, traceback_str: str | None = None):
    """에러를 세션 상태에 로깅"""
    try:
        if "st" in globals() and st is not None:
            import time
            error_logs = st.session_state.get("_ERROR_LOGS", [])
            error_logs.append({
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "type": error_type,
                "message": message,
                "traceback": traceback_str
            })
            # 최대 50개 에러만 유지
            if len(error_logs) > 50:
                error_logs = error_logs[-50:]
            st.session_state["_ERROR_LOGS"] = error_logs
    except Exception:
        pass

# =============================== [03] orchestrator header — START =====================
def render_orchestrator_header() -> None:
    if st is None:
        return

    # 공용 판정기(역호환 허용)
    try:
        from src.core.readiness import is_ready_text, norm_ready_text
    except Exception:
        def _norm(x: str | bytes | None) -> str:
            if x is None:
                return ""
            if isinstance(x, bytes):
                x = x.decode("utf-8", "ignore")
            return x.replace("\ufeff", "").strip().lower()
        def is_ready_text(x):  # type: ignore
            return _norm(x) in {"ready", "ok", "true", "1", "on", "yes", "y", "green"}
        def norm_ready_text(x):  # type: ignore
            return _norm(x)

    st.markdown("### 🧪 인덱스 오케스트레이터")
    persist = _persist_dir_safe()
    with st.container():
        st.caption("Persist Dir")
        st.code(str(persist), language="text")

    # 로컬 준비 상태 재계산(세션 키 보정)
    cj = persist / "chunks.jsonl"
    rf = persist / ".ready"
    try:
        ready_txt = rf.read_text(encoding="utf-8") if rf.exists() else ""
    except Exception:
        ready_txt = ""
    local_ready = cj.exists() and cj.stat().st_size > 0 and is_ready_text(ready_txt)
    st.session_state["_INDEX_LOCAL_READY"] = bool(local_ready)

    # 최신 여부(헤더 칩 결정용) — 앱 세션 플래그 사용
    is_latest = bool(st.session_state.get("_INDEX_IS_LATEST", False))
    latest_tag = st.session_state.get("_LATEST_RELEASE_TAG")

    # 칩 계산 (실제 파일 상태와 세션 상태 모두 고려)
    if is_latest and local_ready:
        badge = "🟩 준비완료"
        badge_code = "READY"
        badge_desc = f"최신 릴리스 적용됨 (tag={latest_tag})" if latest_tag else "최신 릴리스 적용됨"
    elif local_ready:
        badge = "🟨 준비중(로컬 인덱스 감지)"
        badge_code = "MISSING"
        badge_desc = "로컬 인덱스는 있으나 최신 릴리스와 불일치 또는 미확인"
    elif is_latest and not local_ready:
        badge = "🟧 세션 불일치"
        badge_code = "MISSING"
        badge_desc = "세션에서는 최신이지만 실제 파일이 없거나 손상됨"
    else:
        badge = "🟧 없음"
        badge_code = "MISSING"
        badge_desc = "인덱스 없음"

    # iOS 스타일 + 미니멀리즘 디자인 적용
    if bool(st.session_state.get("admin_mode", False)):
        # 자동 스캔 상태 표시 (관리자 전용) - iOS 스타일
        boot_scan_done = st.session_state.get("_BOOT_SCAN_DONE", False)
        has_new_files = st.session_state.get("_PREPARED_HAS_NEW", False)
        new_files_count = st.session_state.get("_PREPARED_NEW_FILES", 0)
        total_files_count = st.session_state.get("_PREPARED_TOTAL_FILES", 0)
        
        # iOS 스타일 상태 표시 CSS
        st.markdown("""
        <style>
        .ios-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 20px 0;
            background: #f2f2f7;
            border-radius: 12px;
            padding: 16px;
        }
        .ios-status-card {
            background: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1f;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .ios-status-icon {
            font-size: 18px;
            margin-bottom: 4px;
            color: #007aff;
        }
        .ios-status-text {
            font-size: 12px;
            color: #8e8e93;
            margin-top: 2px;
        }
        
        /* 모바일 최적화 */
        @media (max-width: 768px) {
            .ios-status-grid {
                grid-template-columns: 1fr;
                gap: 8px;
                margin: 16px 0;
                padding: 12px;
            }
            .ios-status-card {
                padding: 16px 12px;
                min-height: 48px;
                font-size: 16px;
            }
            .ios-status-icon {
                font-size: 20px;
            }
            .ios-status-text {
                font-size: 14px;
            }
        }
        </style>
        """, unsafe_allow_html=True)
        
        # iOS 스타일 시스템 상태 표시
        status_html = '<div class="ios-status-grid">'
        
        # 인덱스 상태 (무채색 아이콘)
        if local_ready and is_latest:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">●</div>
                <div>준비완료</div>
                <div class="ios-status-text">최신 릴리스</div>
            </div>
            '''
        elif local_ready:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">○</div>
                <div>로컬사용</div>
                <div class="ios-status-text">복원 필요</div>
            </div>
            '''
        else:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">○</div>
                <div>복원필요</div>
                <div class="ios-status-text">인덱스 없음</div>
            </div>
            '''
        
        # 스캔 상태 (무채색 아이콘)
        if boot_scan_done:
            if has_new_files:
                status_html += f'''
                <div class="ios-status-card">
                    <div class="ios-status-icon">○</div>
                    <div>새파일 {new_files_count}개</div>
                    <div class="ios-status-text">업데이트 필요</div>
                </div>
                '''
            else:
                status_html += '''
                <div class="ios-status-card">
                    <div class="ios-status-icon">●</div>
                    <div>최신</div>
                    <div class="ios-status-text">동기화 완료</div>
                </div>
                '''
        else:
            status_html += '''
            <div class="ios-status-card">
                <div class="ios-status-icon">◐</div>
                <div>스캔중</div>
                <div class="ios-status-text">처리 중</div>
            </div>
            '''
        
        # 파일 수 표시
        status_html += f'''
        <div class="ios-status-card">
            <div class="ios-status-icon">○</div>
            <div>{total_files_count}개</div>
            <div class="ios-status-text">총 파일</div>
        </div>
        '''
        
        status_html += '</div>'
        st.markdown(status_html, unsafe_allow_html=True)
        
        # 복원 상태 표시 제거 (미니멀리즘)
        # 복원 상태는 시스템 상태 카드에서 충분히 표시됨
        
        # iOS 스타일 버튼 CSS 추가
        st.markdown("""
        <style>
        .ios-button {
            background: #ffffff;
            border: 1px solid #d1d1d6;
            border-radius: 10px;
            padding: 16px 20px;
            font-size: 16px;
            font-weight: 500;
            color: #007aff;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .ios-button:hover {
            background: #f2f2f7;
            border-color: #007aff;
        }
        .ios-button.primary {
            background: #007aff;
            color: #ffffff;
            border-color: #007aff;
        }
        .ios-button.primary:hover {
            background: #0056cc;
        }
        .ios-button-icon {
            font-size: 18px;
            color: inherit;
        }
        
        /* 모바일 최적화 */
        @media (max-width: 768px) {
            .ios-button {
                padding: 20px 24px;
                font-size: 17px;
                min-height: 52px;
            }
            .ios-button-icon {
                font-size: 20px;
            }
        }
        </style>
        """, unsafe_allow_html=True)
        
        # 주요 작업 섹션
        st.markdown("#### 주요 작업")
        
        main_col1, main_col2 = st.columns([1, 1])
        
        with main_col1:
            if st.button("인덱싱 & 업로드", use_container_width=True, type="primary"):
                params = {"auto_up": True, "debug": bool(show_debug)}
                try:
                    run_admin_index_job(params)
                except Exception as e:
                    st.error(f"강제 인덱싱 실패: {e}")
        
        with main_col2:
            if st.button("Release 업로드", use_container_width=True):
                try:
                    used_persist = _persist_dir_safe()
                    z = make_index_backup_zip(used_persist)
                    msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                    st.success(f"Release 업로드 완료: {msg}")
                except Exception as e:
                    st.error(f"Release 업로드 실패: {e}")
        
        # 관리 도구 섹션
        st.markdown("#### 관리 도구")
        
        # 2x2 그리드로 관리 도구 버튼들 배치
        tool_col1, tool_col2 = st.columns([1, 1])
        
        with tool_col1:
            if st.button("파일스캔", use_container_width=True):
                try:
                    # 수동 스캔 실행
                    lister, _ = _load_prepared_lister()
                    if lister:
                        files_list = lister() or []
                        chk, _mark, _ = _load_prepared_api()
                        new_files = []
                        if callable(chk):
                            try:
                                persist_dir = _persist_dir_safe()
                                info = chk(persist_dir, files_list) or {}
                                new_files = list(info.get("files") or info.get("new") or [])
                            except Exception as e:
                                st.error(f"스캔 실행 실패: {e}")
                                return
                        
                        total_files = len(files_list)
                        new_count = len(new_files)
                        
                        if new_count > 0:
                            st.warning(f"🆕 새 파일 {new_count}개 발견! (총 {total_files}개 파일)")
                            st.session_state["_PREPARED_HAS_NEW"] = True
                            st.session_state["_PREPARED_NEW_FILES"] = new_count
                        else:
                            st.success(f"✅ 새 파일 없음 (총 {total_files}개 파일)")
                            st.session_state["_PREPARED_HAS_NEW"] = False
                    else:
                        st.error("prepared 폴더 접근 불가")
                except Exception as e:
                    st.error(f"스캔 실패: {e}")
                    import traceback
                    _log_error("스캔 실패", str(e), traceback.format_exc())
        
        with idx_col2:
            if st.button("✅ 검증", use_container_width=True, key="validation_btn"):
                try:
                    # 실시간으로 파일 상태 재확인 (세션 상태와 무관하게)
                    cj_exists = cj.exists()
                    cj_size = cj.stat().st_size if cj_exists else 0
                    cj_valid = cj_exists and cj_size > 0
                    
                    rf_exists = rf.exists()
                    try:
                        current_ready_txt = rf.read_text(encoding="utf-8") if rf_exists else ""
                    except Exception as e:
                        current_ready_txt = f"<읽기오류: {e}>"
                    
                    ready_valid = is_ready_text(current_ready_txt)
                    current_local_ready = cj_valid and ready_valid
                    
                    ok = current_local_ready
                    if ok:
                        st.success("검증 성공: chunks.jsonl 존재 & .ready 유효")
                    else:
                        st.error("검증 실패: 산출물/ready 상태가 불일치")
                except Exception as e:
                    st.error(f"검증 실행 실패: {e}")
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("검증 실패", str(e), traceback_str)
        
        # 릴리스 관련 도구
        st.markdown("#### 📤 릴리스 관련")
        
        rel_col1, rel_col2 = st.columns([1, 1])
        
        with rel_col1:
            if st.button("🔄 릴리스복원", use_container_width=True, type="primary"):
                try:
                    # 강제 복원 플래그 설정
                    st.session_state["_FORCE_RESTORE"] = True
                
                    # 복원 전 상태 기록
                    pre_restore_state = {
                        "chunks_exists": cj.exists(),
                        "chunks_size": cj.stat().st_size if cj.exists() else 0,
                        "ready_exists": rf.exists(),
                        "ready_content": rf.read_text(encoding="utf-8") if rf.exists() else "",
                        "persist_files": [str(f) for f in persist.iterdir()] if persist.exists() else []
                    }
                    
                    fn = _resolve_app_attr("_boot_auto_restore_index")
                    if callable(fn):
                        try:
                            fn()
                        except Exception as restore_error:
                            st.error(f"복원 중 오류 발생: {restore_error}")
                            import traceback
                            st.code(traceback.format_exc())
                            raise
                    
                    # 복원 후 상태 기록
                    post_restore_state = {
                        "chunks_exists": cj.exists(),
                        "chunks_size": cj.stat().st_size if cj.exists() else 0,
                        "ready_exists": rf.exists(),
                        "ready_content": rf.read_text(encoding="utf-8") if rf.exists() else "",
                        "persist_files": [str(f) for f in persist.iterdir()] if persist.exists() else []
                    }
                    
                    # 복원 결과 저장
                    st.session_state["_RESTORE_DEBUG"] = {
                        "pre_restore": pre_restore_state,
                        "post_restore": post_restore_state,
                        "timestamp": int(time.time())
                    }
                    
                    st.success("Release 복원을 시도했습니다. 상태를 확인하세요.")
                except Exception as e:
                    st.error(f"복원 실행 실패: {e}")
                    st.session_state["_FORCE_RESTORE"] = False  # 플래그 리셋
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("복원 실패", str(e), traceback_str)

        with rel_col2:
            if st.button("💾 로컬복원", use_container_width=True):
                try:
                    from src.runtime.local_restore import find_local_backups, restore_from_local_backup
                    
                    # 로컬 백업 찾기
                    from pathlib import Path
                    backup_base = Path.home() / ".maic"
                    backups = find_local_backups(backup_base)
                    
                    if not backups:
                        st.warning("로컬 백업을 찾을 수 없습니다.")
                        st.info("백업 위치: ~/.maic/backup, ~/.maic/backups, ~/.maic/index_backup 등")
                    else:
                        st.write(f"**발견된 백업 ({len(backups)}개):**")
                        
                        # 백업 목록 표시
                        for i, backup in enumerate(backups[:5]):  # 최대 5개만 표시
                            backup_info = {
                                "path": str(backup),
                                "type": "디렉터리" if backup.is_dir() else "압축파일",
                                "size": f"{backup.stat().st_size / 1024 / 1024:.1f}MB" if backup.is_file() else "N/A"
                            }
                            st.write(f"{i+1}. {backup_info['type']}: {backup.name}")
                        
                        # 첫 번째 백업으로 복원 시도
                        success, message = restore_from_local_backup(backups[0], persist)
                        
                        if success:
                            st.success(f"✅ {message}")
                            # 세션 상태 업데이트
                            st.session_state["_INDEX_LOCAL_READY"] = True
                            st.session_state["_INDEX_IS_LATEST"] = False  # 로컬 복원이므로 최신 아님
                            st.rerun()
                        else:
                            st.error(f"❌ {message}")
                
                except Exception as e:
                    st.error(f"로컬 복원 실패: {e}")
                    import traceback
                    traceback_str = traceback.format_exc()
                    st.code(traceback_str)
                    _log_error("로컬 복원 실패", str(e), traceback_str)

        with st.expander("최근 검증/복원 기록", expanded=False):
            rec = st.session_state.get("_LAST_RESTORE_CHECK")
            st.json(rec or {"hint": "위의 복원/검증 버튼을 사용해 기록을 남길 수 있습니다."})

        with st.expander("ℹ️ 최신 릴리스/메타 정보", expanded=False):
            st.write({
                "latest_release_tag": latest_tag,
                "latest_release_id": st.session_state.get("_LATEST_RELEASE_ID"),
                "last_restore_meta": st.session_state.get("_LAST_RESTORE_META"),
                "is_latest": is_latest,
                "local_ready": local_ready,
            })
            
        # 복원 디버그 정보 표시
        restore_debug = st.session_state.get("_RESTORE_DEBUG")
        if restore_debug:
            with st.expander("🔧 복원 디버그 정보", expanded=True):
                st.json(restore_debug)
        
        # 에러 패널 추가
        st.markdown("#### 🚨 에러 로그")
        error_logs = st.session_state.get("_ERROR_LOGS", [])
        
        if error_logs:
            # 최근 에러 5개만 표시
            recent_errors = error_logs[-5:]
            for i, error in enumerate(reversed(recent_errors)):
                with st.expander(f"에러 {len(error_logs) - i}: {error.get('timestamp', 'Unknown')}", expanded=(i == 0)):
                    st.error(f"**타입**: {error.get('type', 'Unknown')}")
                    st.error(f"**메시지**: {error.get('message', 'No message')}")
                    if error.get('traceback'):
                        st.code(error['traceback'], language='python')
                    
                    # 복사 버튼
                    if st.button(f"📋 에러 {len(error_logs) - i} 복사", key=f"copy_error_{i}"):
                        error_text = f"에러 타입: {error.get('type', 'Unknown')}\n"
                        error_text += f"에러 메시지: {error.get('message', 'No message')}\n"
                        if error.get('traceback'):
                            error_text += f"스택 트레이스:\n{error['traceback']}"
                        st.code(error_text, language='text')
                        st.success("에러 내용이 위에 표시되었습니다. 복사하여 사용하세요.")
        else:
            st.info("에러 로그가 없습니다.")
        
        # 에러 로그 초기화 버튼
        if st.button("🗑️ 에러 로그 초기화", use_container_width=True):
            st.session_state["_ERROR_LOGS"] = []
            st.success("에러 로그가 초기화되었습니다.")
            st.rerun()
        
        # 릴리스 자산 정보 확인 버튼 추가
        if st.button("🔍 릴리스 자산 정보 확인", use_container_width=True):
            try:
                from src.runtime.gh_release import GHConfig, GHReleases
                import os
                
                # GitHub 설정
                repo_full = st.secrets.get("GITHUB_REPO", os.getenv("GITHUB_REPO", ""))
                token = st.secrets.get("GITHUB_TOKEN", os.getenv("GITHUB_TOKEN"))
                
                if "/" not in str(repo_full):
                    st.error("GITHUB_REPO 설정이 필요합니다.")
                    return
                
                owner, repo = str(repo_full).split("/", 1)
                gh = GHReleases(GHConfig(owner=owner, repo=repo, token=token))
                
                # 최신 릴리스 정보 조회
                latest_rel = gh.get_latest_release()
                if latest_rel:
                    st.success(f"최신 릴리스: {latest_rel.get('tag_name')}")
                    assets = latest_rel.get("assets", [])
                    if assets:
                        st.write("**자산 목록:**")
                        for asset in assets:
                            st.write(f"- {asset.get('name')} ({asset.get('size', 0)} bytes)")
                    else:
                        st.warning("자산이 없습니다.")
                else:
                    st.error("릴리스를 찾을 수 없습니다.")
                    
            except Exception as e:
                st.error(f"릴리스 정보 조회 실패: {e}")
                import traceback
                st.code(traceback.format_exc())

        try:
            _dbg = _resolve_app_attr("_render_release_candidates_debug")
            if callable(_dbg):
                _dbg()
        except Exception:
            pass

    # 학생 화면에서는 간단한 상태만 표시
    local_ready = st.session_state.get("_INDEX_LOCAL_READY", False)
    is_latest = st.session_state.get("_INDEX_IS_LATEST", False)
    
    if local_ready and is_latest:
        st.success("✅ 시스템 준비 완료", icon="✅")
    elif local_ready:
        st.warning("⚠️ 로컬 인덱스 사용 중 (최신 아님)", icon="⚠️")
    else:
        st.error("❌ 인덱스 없음 - 관리자 모드에서 복원하세요", icon="❌")
    
    st.info(
        "관리자 모드에서 인덱스 관리, 스캔, 재인덱싱을 수행할 수 있습니다.",
        icon="ℹ️",
    )
    st.markdown("<span id='idx-admin-panel'></span>", unsafe_allow_html=True)
# ================================ [03] orchestrator header — END ======================

# =============================== [04] prepared scan — START ===========================
def render_prepared_scan_panel() -> None:
    if st is None or not bool(st.session_state.get("admin_mode", False)):
        return

    st.markdown("<h4>🔍 새 파일 스캔(인덱싱 없이)</h4>", unsafe_allow_html=True)

    c1, c2, _c3 = st.columns([1, 1, 2])
    act_scan = c1.button("🔍 스캔 실행", use_container_width=True)
    act_clear = c2.button("🧹 화면 지우기", use_container_width=True)

    if act_clear:
        st.session_state.pop("_PR_SCAN_RESULT", None)
        try:
            _sr = _resolve_app_attr("_safe_rerun")
            if callable(_sr):
                _sr("pr_scan_clear", ttl=1)
        except Exception:
            pass

    prev = st.session_state.get("_PR_SCAN_RESULT")
    if isinstance(prev, dict) and not act_scan:
        st.caption("이전에 실행한 스캔 결과:")
        st.json(prev)

    if not act_scan:
        return

    idx_persist = _persist_dir_safe()
    lister, dbg1 = _load_prepared_lister()
    files_list: List[Dict[str, Any]] = []
    if lister:
        try:
            files_list = lister() or []
        except Exception as e:
            st.error(f"prepared 목록 조회 실패: {e}")
    else:
        with st.expander("디버그(파일 나열 함수 로드 경로)"):
            st.write("\n".join(dbg1) or "(정보 없음)")

    chk, _mark, dbg2 = _load_prepared_api()
    info: Dict[str, Any] = {}
    new_files: List[str] = []
    if callable(chk):
        try:
            info = chk(idx_persist, files_list) or {}
        except TypeError:
            info = chk(idx_persist) or {}
        except Exception as e:
            st.error(f"스캔 실행 실패: {e}")
            info = {}
        try:
            new_files = list(info.get("files") or info.get("new") or [])
        except Exception:
            new_files = []
    else:
        with st.expander("디버그(소비 API 로드 경로)"):
            st.write("\n".join(dbg2) or "(정보 없음)")

    total_prepared = len(files_list)
    total_new = len(new_files)
    st.success(f"스캔 완료 · prepared 총 {total_prepared}건 · 새 파일 {total_new}건")

    if total_new:
        with st.expander("새 파일 미리보기(최대 50개)"):
            rows = []
            for rec in (new_files[:50] if isinstance(new_files, list) else []):
                if isinstance(rec, str):
                    rows.append({"name": rec})
                elif isinstance(rec, dict):
                    nm = str(rec.get("name") or rec.get("path") or rec.get("file") or "")
                    fid = str(rec.get("id") or rec.get("fileId") or "")
                    rows.append({"name": nm, "id": fid})
            if rows:
                st.dataframe(rows, hide_index=True, use_container_width=True)
            else:
                st.write("(표시할 항목이 없습니다.)")
    else:
        st.info("새 파일이 없습니다. 재인덱싱을 수행할 필요가 없습니다.")

    st.session_state["_PR_SCAN_RESULT"] = {
        "persist": str(idx_persist),
        "prepared_total": total_prepared,
        "new_total": total_new,
        "timestamp": int(time.time()),
        "sample_new": new_files[:10] if isinstance(new_files, list) else [],
    }
# ================================ [04] prepared scan — END ============================

def render_index_panel() -> None:
    """관리자 인덱싱 패널 본문."""
    if st is None:
        return

    st.markdown("### 🔧 관리자 인덱싱 패널 (prepared 전용)")

    # 2) 옵션/버튼 영역
    colA, colB = st.columns([1, 1])
    with colA:
        show_debug = st.toggle("디버그 로그 표시", value=True, key="idx_show_debug")
    with colB:
        if st.button("📤 Release로 업로드", use_container_width=True, key="idx_manual_upload"):
            try:
                used_persist = _persist_dir_safe()
                z = make_index_backup_zip(used_persist)
                msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                st.success(f"업로드 완료: {msg}")
            except Exception as e:
                st.error(f"업로드 실패: {e}")

    # 4) 인덱싱 및 업로드 버튼들 (나란히 배열)
    col1, col2 = st.columns([1, 1])
    
    with col1:
        if st.button("🚀 인덱싱 및 업로드", type="primary",
                     use_container_width=True, key="idx_run_btn"):
            params = {"auto_up": True, "debug": bool(show_debug)}
            try:
                run_admin_index_job(params)
            except Exception as e:
                st.error(f"강제 인덱싱 실패: {e}")
    
    with col2:
        if st.button("📤 Release 업로드", type="secondary",
                     use_container_width=True, key="release_upload_btn"):
            try:
                used_persist = _persist_dir_safe()
                z = make_index_backup_zip(used_persist)
                msg = upload_index_backup(z, tag=f"index-{int(time.time())}")
                st.success(f"Release 업로드 완료: {msg}")
            except Exception as e:
                st.error(f"Release 업로드 실패: {e}")

    # 5) 마지막으로 한 번 더 진행/상태 렌더(관리자 모드에서만)
    if bool(st.session_state.get("admin_mode", False)):
        try:
            render_index_steps()
        except Exception:
            pass
# ================================ [05] indexing panel — END ===========================

# =============================== [06] indexed sources — START =========================
def render_indexed_sources_panel() -> None:
    if st is None or not bool(st.session_state.get("admin_mode", False)):
        return

    chunks_path = _persist_dir_safe() / "chunks.jsonl"
    with st.container(border=True):
        st.subheader("📄 인덱싱된 파일 목록 (읽기 전용)")
        # persist Dir 경로 표시 제거 (미니멀리즘)

        if not chunks_path.exists():
            st.info("아직 인덱스가 없습니다. 먼저 인덱싱을 수행해 주세요.")
            return

        docs: Dict[str, Dict[str, Any]] = {}
        total_lines = 0
        parse_errors = 0
        try:
            with chunks_path.open("r", encoding="utf-8") as rf:
                for line in rf:
                    s = line.strip()
                    if not s:
                        continue
                    total_lines += 1
                    try:
                        obj = json.loads(s)
                    except Exception:
                        parse_errors += 1
                        continue
                    doc_id = str(obj.get("doc_id") or obj.get("source") or "")
                    title = str(obj.get("title") or "")
                    source = str(obj.get("source") or "")
                    if not doc_id:
                        continue
                    row = docs.setdefault(
                        doc_id, {"doc_id": doc_id, "title": title, "source": source, "chunks": 0}
                    )
                    row["chunks"] += 1
        except Exception as e:
            try:
                _err = _resolve_app_attr("_errlog")
                if callable(_err):
                    _err(f"read chunks.jsonl failed: {e}", where="[indexed-sources.read]", exc=e)
            except Exception:
                pass
            st.error("인덱스 파일을 읽는 중 오류가 발생했어요.")
            return

        rows2 = [
            {"title": r["title"], "path": r["source"], "doc_id": r["doc_id"], "chunks": r["chunks"]}
            for r in docs.values()
        ]
        st.caption(
            f"총 청크 수: {total_lines} · 문서 수: {len(rows2)} (파싱오류 {parse_errors}건)"
        )
        st.dataframe(rows2, hide_index=True, use_container_width=True)
# ================================ [06] indexed sources — END ==========================
